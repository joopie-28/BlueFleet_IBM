---
title: 'Predator, prey and strandings: An IBM approach to modelling the ''Blue Fleet'''
author: "J.M. Sassen"
date: "`r Sys.Date()`"
output:
  html_document: default
---
<p align="center">
![](./Images/BlueFleet_Image_ABC.jpeg)
</p>

<style type="text/css">
.main-container {
  max-width: 1250px;
  margin-left: auto;
  margin-right: auto;
}


</style>

<style>
p.caption {
  font-size: 1em;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, incl = T, message = F, warning = F)
library(tidyverse)
```

# 1. Introduction

<p align="justify">
The blue fleet refers to a community of neustonic (i.e. drifting or floating with winds and currents) organisms, with a cosmopolitan distribution (Bourg *et al*., 2022). The community consists of several species of Cnidaria (Jellyfish and relatives) as well as a variety of Molluscs (Helm, 2021). Aggregations of these organisms may cover extremely large areas, sometimes spanning several kilometers. Whilst large fleets are generally confined to offshore areas, such as oceanic gyres, strong onshore winds and currents can cause mass strandings of these creatures (Bourg *et al*., 2022). This poses a risk to swimmers and beachgoers, as several constituent species possess the ability to envenomate people or animals upon touch (e.g. the Bluebottle). The exact dynamics driving stranding of harmful species are not completely understood, however this is an area of active research (e.g. Bourg *et al*., 2022; Lee *et al*., 2021). Interestingly, there is some variability in the number of species that one might find during a mass stranding event: sometimes we see all species strand, whilst at other times only one species may be recorded (Grove, 2010). This could be explained by the inherent morphological differences between the species that make up the blue fleet. For example, several cnidarians, including the bluebottle and the by-the-wind sailor (*Vellela vellela*), have evolved an enlarged membrane filled with gas that serves as a sail. Individual bluebottles come in a right or left-sailed orientation: these two morphotypes will drift in opposite directions from each other (Bourg *et al*., 2022; Lee *et al*., 2021). Other functional groups, such as the pelagic slugs that prey on the floating cnidarians, lack such structures. Thus, whilst all these species are considered part of the blue fleet, physical forces might affect them in different ways.
</p>
<p align="justify">
Here, we simulate the drifting dynamics of two species that are part of the blue fleet: The bluebottle *Physalia physalis* (Cnidaria: Siphonophora) and The 'Blue Dragon' *Glaucus atlanticus* (Gastropoda: Nudibranchia), a pelagic sea slug and a predator of *P. physalis*. Drifting behaviour, and associated beaching probabilities for each species were investigated through the use of an Individual Based Model (IBM). We incorporate meaningful ecological interactions between the two species, such as predation, to promote realism of the drifting dynamics. Not much is known about how Blue Dragons find their prey. However, it is possible that they are capable of very limited directed movement, as well as chemodetection of nearby prey using specialised structures known as rhinophores (Valdes & Compillo, 2004). Helm (2021) found that different species of pelagic slugs had distinct unique predatory preferences and behaviours when exposed to prey in a laboratory environment. Alternatively, prey density might be so high that Blue Dragons simply rely on chance encounters with prey. By simulating this system with different combinations of prey densities and biological parameters, we aim to generate insights into how a small neustonic predator finds prey. 
</p>
<p align="justify">
We thus strive to answer the following questions:

1. *How do beaching probabilities differ between the two species?*

2. *How do prey density, swimming speed and chemodetection affect the number of predator-prey interactions?*
</p>

# 2. Model Elaboration

## 2.1 Conceptual Overview
<p align="justify">
The model is designed to investigate the effects of physical factors such as wind and ocean currents on the movement and behavior of the two species. We created a 100km x 10km grid, with a spatial resolution of 1 km (1,000 total cells). Cells with x-values > 1km were assigned a 'land' status and all other cells where assigned an 'ocean' status. This resulted in a straight coastline stretching the left side of the grid, emulating a simplified Eastern Australian Coastline. Each individual cell was then assigned a value for the following physical parameters: Wind Speed, Wind Direction, Current Speed, Current Direction. The temporal resolution was 1 hour. Thus, all speed parameters are in km/H, and each simulation iteration represents 1 hour in real-time.
</p>
<p align="justify">
The environment was then populated with individual *G. atlanticus* and *P. physalis*, each with their own unique attributes. For *G. atlanticus*, we assigned the following attributes: initial X coordinate, initial Y coordinate, chemodetection range, and movement speed. As both chemodetection and speed are traits that are expected to vary between *G. atlanticus*, these were assigned by drawing from a normal distribution with mean = 1 meter and sd = 0.25 meter for chemodetection and mean = 0.15 cm/H and sd = 3.75 (proportion of sd to mean was unchanged for simulations in which speed and chemodetection were varied). There was no prior information available for these values, so they are largely based on assumptions. Individual *G. atlanticus* could end up beached or alive at the end of the simulation. For *P. physalis*, the following attributes were assigned: initial X coordinate, initial Y coordinate and orientation. Orientation refers to the position of the sail relative to the tentacles: this comes in a 'right-handed' or 'left-handed' variation. This variable was assigned randomly for each individual. Individual *P. physalis* could end up beached, eaten, or alive at the end of the simulation.
</p>
<p align="justify">
Whilst the grid resolution was 1km, our model allows individuals to move through continuous space. The movement of an individual depends on the winds and current within the current cell, however the effect of these drivers might only amount to a movement of 20 cm within a timestep. This value is used to update the position of the individual. On the next iteration, the individual will simply 'feel' the same physical drivers, as it still finds itself in the same cell. Thus, movement is decoupled from grid cells, but the effect of wind and currents on the position of an individual does depend on the grid cell they are in. This enables us to include the biological interactions that occur on the scale of centimeters.
</p>

* ***Note: I initially opted for a grid approach as I was thinking about assigning distinct directions and speeds to different parts of the simulated environment. I did not end up doing this, so the grid structure is not really necessary, however I left it in as it makes no difference and allows me to maybe make those changes in a future version.***

## 2.2 Movement Equations

\n

### 2.2.1 Glaucus atlanticus
$$
X_{j,i+1} = X_{ij} + 0.01 * WindSpeed_{{xy,i}} sin(WindDirection_{xy,i}) + 0.005 * CurrentSpeed_{xy,i} * sin(CurrentDirection_{xy,i}) + C * (GlaucusSpeed_{ij} * sin(atan(Y_{Prey} - Y_i, X_{Prey} - X_i)))
$$
$$
Y_{j,i+1} = Y_{ij} + 0.01 * WindSpeed_{{xy,i}} * cos(WindDirection_{xy,i}) + 0.005 * CurrentSpeed_{xy,i} * cos(CurrentDirection_{xy,i}) + C * (GlaucusSpeed_{ij} * cos(atan(Y_{Prey} - Y_{ij}, X_{Prey} - X_{ij} )) )
$$
***Where:*** 

$$
X_{j,i+1} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
X_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{j,i+1} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
Y_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
WindSpeed_{xy,i} = \text{Wind Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
WindDirection_{xy,i} = \text{Wind Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentSpeed_{xy,i} = \text{Current Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentDirection_{xy,i} = \text{Current Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
GlaucusSpeed_{i,j} = \text{Swimming Speed}\,\text{for}\, Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{prey} = \text{Y coordinate of closest prey for}\, Individual_{j } \text{ at Time = } i \\
X_{prey} = \text{X coordinate of closest prey for}\, Individual_{j } \text{ at Time = } i \\
Prey = ∀Physalia \\
C = \begin{cases}
1, & \text{if Prey within } Detection Range_j \\
0, & \text{if Prey beyond } Detection Range_j
\end{cases}
$$

<p align="justify">
The movement of *G. atlanticus*s depends on physical and biological parameters. For iteration i of the model, the position of an individual is given by the x and y coordinate. The displacement between time = i and time = i + 1 is given by above equations. The effects of winds and current depend on i) the speed in km/h and ii) the direction in radians. Sin(direction) then gives vertical (north-south) displacement, whilst cos(direction) gives horizontal (east-west). To illustrate, if wind is blowing from the east, direction equals 1.5 * pi. Displacement can then be calculated as:
</p>

$$
\Delta_{x} = sin(1.5 * pi) * speed = -1*speed \\
\Delta_{y} = cos(1.5*pi) = 0 \\
\text{Thus, wind from the east will move an individual to the west}
$$

<p align="justify">
In addition, we allow *G. atlanticus* to make small directed movements towards prey, if their prey is within a certain 'detection zone'. The size of this detection zone depends on the chemodetection abilities of an individual *G. atlanticus*. If a prey item is within the zone, we calculate the angle in radians between the predator and the prey, and multiply this new direction by the speed of that particular *G. atlanticus*. The *G. atlanticus* will always move to the closest prey item it detects.
</p>

```{r GA Movement, eval = F, incl = T}
# Movement of Glaucus: depends on an individual glaucus and the physalia fleet
glaucusMovement <- function(glaucus, physalia){
  
  # Boundary conditions for movement, i.e. out of frame.
  # stop updating if this is the case
  if(glaucus$y >= 100 | glaucus$y <= 1 | glaucus$x >= 10){ 
    return(glaucus)}
  
  # First check if glaucus are 'latched on' to physalia which will 
  # affect their movement. The physalia has to be alive.
  if(!is.na(glaucus$target_ID) & physalia[glaucus$target_ID,'status'][1] != 'EATEN'){
    glaucus$x <- physalia[glaucus$target_ID,'x']
    glaucus$y <- physalia[glaucus$target_ID,'y']
    glaucus$latch_time <- glaucus$latch_time + 1
    glaucus$total_latch_time <- glaucus$total_latch_time + 1
    
    # Probability of glaucus detaching follows a beta prime distribution.
    # Shape of distribtution set to match expected behaviour - though arbitrary.

    probs <- c(1-pbetapr(glaucus$latch_time, 24, 5), pbetapr(glaucus$latch_time, 24, 5))
    glaucus$target_ID <- sample(size=1, x = c(glaucus$target_ID, NA), prob = probs) # NA corresponds to letting go of prey.
    
  }else{
    
    
    # Check the Glaucus is not beached, if OK, proceed with movement update
    # as effect of physical forces
    if(glaucus$x > 1){
   
      # Positional update rules: movement of a Glaucus
      # We use ceiling() to round up and extract force values from the grids.
      # The grids are set globally prior to function call.
      glaucus$x <- glaucus$x + 0.01*wind_strength[ceiling(glaucus$y), 
                                                   ceiling(glaucus$x)] * sin(wind_direction[ceiling(glaucus$y), 
                                                                                            ceiling(glaucus$x)])+
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * sin(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      # Y movement (north - south) uses cosine function
      glaucus$y <- glaucus$y + 0.01*wind_strength[ceiling(glaucus$y), 
                                                   ceiling(glaucus$x)] * cos(wind_direction[ceiling(glaucus$y), 
                                                                                            ceiling(glaucus$x)]) +
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * cos(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      ### Predator module - handles the predator behaviour
      
      # Glaucus are predators. They can detect prey from distance using chemical cues. We want to simulate these capabilities
      # by allowing glaucus limited movement to a target, if the target is within reasonable range.
      
      # scan area for each glaucus
      # Convert to spatial geometries to allow geometric operations.
      spat.point <- st_point(c(glaucus$x, glaucus$y))
      
      # Chemodetection range calculated as circle with radius equal to 
      # the predetermined parameter.
      detection.zone <- st_buffer(spat.point, glaucus$chemodetection)
      
      # Find the Physalia that are within the detection zone.
      physalia.df.spat <- st_as_sf(physalia , coords = c('x', 'y'))
      
      # Any prey in the detection zone?
      if(any(st_intersects(physalia.df.spat, detection.zone, sparse = F))){
        # Find the nearest Physalia
        print('Attack!') # to check if all is ok
        
        # extract some info on the prey
        glaucus.target <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'geometry']]
        glaucus.target.id <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'ID']]
        
        # Now make it move towards the target. We just assume it 
        # is quite good at sensing prey so its movement is 
        # directed.
        
        target_angle <- atan2(glaucus.target[2] - glaucus$y, glaucus.target[1] - glaucus$x) # atan2 calculates the angle to get from y to x
        glaucus$x <- glaucus$x + glaucus$speed * cos(target_angle) 
        glaucus$y <- glaucus$y +  glaucus$speed * sin(target_angle)
        
        # track interaction - defined as entities being close enough to change behaviour 
        # i.e. sensing, eating, latching
        glaucus$interaction <- as.numeric(glaucus$interaction) + 1
        
        # Latch-on module
        eating.zone <- st_buffer(spat.point, 0.0005) 
        if(st_intersects(physalia.df.spat[glaucus.target.id,], eating.zone, sparse = F)){
          print('LATCHED')
          
          # Identify the prey to latch on and store as glaucus attribute
          glaucus$target_ID <- glaucus.target.id 
          
        }
      }
      
      
    } else{
      glaucus$status <- 'BEACHED' # glaucus is beached
    }
  }
  return(glaucus)
}
```
<br>

### 2.2.2 Physalia physalis
$$
X_{j,i+1} = X_{ij} + 0.0266*(WindSpeed_{{xy,i}} * sin(WindDirection_{xy,i}+ D_{ij})) + 0.001 *CurrentSpeed_{xy,i} * sin(CurrentDirection_{xy,i}) \\
Y_{j,i+1} = Y_{ij} + 0.0266*(WindSpeed_{{xy,i}} * cos(WindDirection_{xy,i}+ D_{ij})) + 0.001 * CurrentSpeed_{xy,i} * cos(CurrentDirection_{xy,i})
$$
<p align="center">
***Where:*** 
</p>
$$
X_{j,i+1} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
X_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{j,i+1} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
Y_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
WindSpeed_{xy,i} = \text{Wind Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
WindDirection_{xy,i} = \text{Wind Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentSpeed_{xy,i} = \text{Current Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentDirection_{xy,i} = \text{Current Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
D_{ij} = \begin{cases}
normal(pi/3, 0.25) & \text{if Orientation}_j = Right \\
normal(-pi/3,0.25) & \text{if Orientation}_j = Left
\end{cases} \text{at Time = } i \\
Orientation_j = \text{Sail Orientation of Individual}_j \text{ at Time = } i
$$

*P. physalis* moves at ~2.66% the speed of the wind (Lee *et al*., 2021). Left-sailed individuals will be pushed in a direction 50 degrees to the left of the prevailing wind, whilst right handed individuals move 50 degrees to the right of prevailing winds (Bourg *et al*., 2022). The effect of currents on *P. physalis* is then described using similar equations as for Glaucus.
```{r PP Movement, eval=F, include=TRUE}

# Movement of Physalia
physaliaMovement <- function(physalia, glaucus){
  
  # Boundary conditions for movement, i.e. out of frame
  # stop updating if this happens
  if(physalia$y >= 100 | physalia$y <= 1 |physalia$x >= 100){
    
    return(physalia)}

  # Check Physalia is alive and not beached
  if(physalia$x > 1 & physalia$status != 'EATEN'){
    
    ### Predator-prey module
    
    # We want to simulate damage to the physalia, i.e. being killed by a predator.
    # We use a simple rule: if the glaucus is within feeding range of the physalia
    # for 24 hours, the physalia has been eaten completely. The glaucus will then also
    # move on as we assign status 'eaten' to the physalia. 
    
    # Convert to spatial geometries to allow geometric operations.
    spat.point <- st_point(c(physalia$x, physalia$y))
    
    # We can decide what a reasonable buffer is. This is the same for
    # all physalia. 
    under.attack.zone <- st_buffer(spat.point, 0.0005)
    
    # Check if there is a predator nearby
    glaucus.df.spat <- st_as_sf(glaucus , coords = c('x', 'y'))
    
    # Any predators in the detection/eating zone?
    if(any(st_intersects(glaucus.df.spat, under.attack.zone, sparse = F))){
      
      # If yes, the physalia is 'under attack'
      physalia$underattack <- physalia$underattack + 1
    }
    # Check if physalia is eaten 
    if(physalia$underattack >= 24){
      physalia$status <- 'EATEN'
    }
    
    # We have right and left=handed bluebottles
    # They drift in opposite directions - presumably to sustain populations.
    # We need to account for this properly. In addition, we want to add some
    # stochasticity to the movement. This is due to inherent variability
    # in the shape and size of bluebottles, but also due to waves etc.
    
    if(physalia$orientation == 'right') {direction_offset <- rnorm(1,1,0.25)*pi/3} # right-handed drift at 50 degrees from wind direction.
    if(physalia$orientation == 'left') {direction_offset <- rnorm(1,-1,0.25)*pi/3} # left handed drift at ``
    
    # Positional update rules:
    # Wind has a larger impact on physalia due to the sail
    # physalia also have an offset - their sails change the way they interact with wind. 
    # We also assume current has a slightly smaller effect on them than on glaucus

    # 0.0266 - see Lee, Schaeffer, Groeskamp (2021) for justification.
    physalia$x <- physalia$x + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * sin(wind_direction[ceiling(physalia$y), 
                                                                                                          ceiling(physalia$x)]+ direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * sin(current_direction[ceiling(physalia$y), 
                                                                                     ceiling(physalia$x)])
    
    # Y movement (north - south) uses cosine function
    physalia$y <- physalia$y + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * cos(wind_direction[ceiling(physalia$y), 
                                                                                                          ceiling(physalia$x)] + direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * cos(current_direction[ceiling(physalia$y), 
                                                                                     ceiling(physalia$x)])
    
  } else{
  
    # Check if individual is beached
    if(physalia$x <= 1){
      physalia$status <- 'BEACHED'
    }
  }
  return(physalia)
}

```


### 2.3 Biological Interactions
<p align="justify">
Both species are able to interact with each other in the model, and this potentially affects their movements. *G. atlanticus* will seek out nearby *P. physalis* as described in section 2.2.1. However, they may also 'latch' on to a *P. physalis*. This emulates feeding behaviour in which *G. atlanticus* move within the tentacles of a *P. physalis*: *G. atlanticus* may then move with the *P. physalis*, until it stops feeding or completely depletes the resource. Consequently, the time it takes to deplete the resource equals the time it takes for a *P. physalis* to be killed. We assume that an individual *P. physalis* cannot survive unlimited attacks by *G. atlanticus*, and thus an individual that spends more than 24 hours 'under attack' will be assigned the status 'EATEN' and no further movements are simulated. Any *G. atlanticus* that was 'latched on' to the deceased prey, or one that simply stops feeding, then reverts to their regular movement equations. Individual *G. atlanticus* may also detach from prey before consuming it. We model detachment using a beta prime distribution (α = 24, β = 5), by letting the probability of detaching equal the probability of observing a given latch time from the specified beta prime distribution. 
</p>
```{r Latch on equations, eval=F, include=TRUE}

```

### 2.4 Stochasticity of Winds and Currents

<p align="justify">
We strived to emulate the wind and current regime of the East Australian coastline. The primary current is the EAC, which flows in a southward direction. The current speed was initialized at a  5 km/H; this was deemed reasonable as the top speed of the EAC is thought to be around 7 km/H (XXX). We then allowed speeds to increase or decrease stochastically, within a range of 2 km/H - 7 km/H. Wind and current direction were initialized at 315° and 180° and allowed to vary: wind direction varies between 225° and 315°, whilst current direction varies between 160° and 200°. This approach directions did not 'jump' randomly, but instead changed due to small stochastic increases or decreases. These ranges were based on available data (WillyWeather, 2023; Middleton *et al*., 1996). 
</p>
<p align="justify">
Wind speed was modeled following a slightly different approach. Wind speed generally follows a daily cycle, in which wind builds up throughout the day. We simulated this using a sine function with added gaussian noise - this function is featured in the following code chunk.
</p>
```{r physical wind force, eval=F, include=TRUE}
# Stochastic parameter wind strength
wind_strength_calc <-function(hour) {
  # Parameters for the sinusoidal function
  peak_hour <- 20        # Hour of the day with maximum wind
  amplitude <- 5       # Amplitude of the sinusoidal function (half of the variation)
  
  
  # Calculate daylight hours using a sinusoidal function
  strength = amplitude * sin((hour - peak_hour) * 2 * pi / 24) + 10 
  strength = (strength + rnorm(length(hour), 0, sd = 3))
  strength[which(strength<0)] <- 0
  return(strength)
}
```


# 3. Model Simulations

<p align="justify">
In order to effectively answer our research questions, we designed a simulation strategy consisting of two distinct parts: i) running 32 replicates of the simulation using fixed behavioral parameters and assessing beaching proportions of each species and ii) running 50 simulations, each with a different combination of chemodetection range and swimming speed between 0 and 20 meters, obtained from a Latin Square Sampling design, at three different densities of *P. physalis* (a total of 150 unique simulations). All simulations were run on a HPC cluster - bash scripts used are included in the appendix.
</p>
## 3.1 Simulation Function
<p align="justify">
We created a main simulation function that handles creation of the environment, instantiation of agents, and movement updates based on a fixed number of hours or iterations. The function takes 10 parameters to achieve this.
</p>
```{r FullSim, eval=F, include=TRUE}

# Function for running simulation 
simBlueFleet.stochPhys <- function(nTimes,n_rows, n_cols, nPhysalia, nGlaucus,
                                   strength_current,
                                   dir_wind, dir_current,
                                   glaucus_Chemodetection, glaucus_Speed, iniSpace){
  
  # Assign wind and current speed and direction to each grid cell.
  # Based on param input
  current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                              nrow=n_rows)
  
  # Wind and current directions
  
  wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                            nrow=n_rows, ncol=n_cols)
  current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                               nrow=n_rows, ncol=n_cols)
  
  
  ### Instantiate model agents
  
  # Glaucus atlanticus individuals
  print('Generating animals')
  # Our individuals also have attributes. Glaucus are our predators.
  # They will seek out Physalia, and are capable of (very limited)
  # powered movement. 
  
  glaucus <- data.frame(matrix(nrow=nGlaucus, ncol=10))
  colnames(glaucus) <- c("ID", "x", "y", "chemodetection", "speed", "latch_time","total_latch_time", "target_ID", "interaction", "status")
  for (i in 1:nGlaucus) {
    glaucus[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      chemodetection = rnorm(1, glaucus_Chemodetection, glaucus_Chemodetection/4), 
      speed = rnorm(1,glaucus_Speed, sd = glaucus_Speed/4),
      latch_time = 0,
      total_latch_time = 0,
      target_ID = NA,
      interaction = 0,
      status = 'ALIVE'
    )
  }
  
  # Set up bluebottle movement and functions. Bluebottles can be right
  # or left handed.
  physalia <- data.frame(matrix(nrow=nPhysalia, ncol=6))
  colnames(physalia) <- c("ID", "x", "y", "underattack", "status", "orientation")
  
  for (i in 1:nPhysalia) {
    physalia[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      underattack = 0,
      status = 'ALIVE',
      orientation = sample(c('left', 'right'),1)
    )
  }
  
  print('Simulating Dynamics')
  GlaucusSim <- list()
  PhysaliaSim <- list()
  
  # Run model over nTimes steps.
  for (i in 1:nTimes){
    print(i)
    wind_strength <<- matrix(rep(wind_strength_calc(i),n_rows*n_cols), 
                             nrow=n_rows)
    # Wind and current directions vary each hour, but within boundaries
    dir_wind = ifelse(rnorm(1, dir_wind, 0.1) > 1.75*pi, 1.75*pi, 
                      ifelse(rnorm(1, dir_wind, 0.1) < 1.25*pi, 1.25*pi,
                             rnorm(1, dir_wind, 0.1))) |> sin()
      
    
    dir_current = ifelse(rnorm(1, dir_current, 0.1) > 3.5, 3.5, 
                         ifelse(rnorm(1, dir_current, 0.1) < 2.9, 2.9,
                                rnorm(1, dir_current, 0.1)))
    
    strength_current = ifelse(rnorm(1, strength_current, 0.1) > 7, 7, 
                         ifelse(rnorm(1, strength_current, 0.1) < 2, 2,
                                rnorm(1, strength_current, 0.1)))
    
    wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                              nrow=n_rows, ncol=n_cols)
    current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                                 nrow=n_rows, ncol=n_cols)
    current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                                nrow=n_rows)
    
    # Update Physalia movement
    for(k in 1:nPhysalia){
      
      # This function updates the position of all simulated
      # Physalia. Also tracks their 'status', which may be one
      # of 'ALIVE', 'BEACHED', or 'EATEN'.
      physalia[k, ] <- physaliaMovement(physalia[k,], glaucus)
    }
    
    PhysaliaSim[[i]] <- physalia
    
    
    # Update Glaucus movement. Status includes 'BEACHED' or 'ALIVE'.
    for(j in 1:nGlaucus){
      glaucus[j,] <- glaucusMovement(glaucus[j,], physalia)
      
    }
    GlaucusSim[[i]] <- glaucus
  }
  simResults <- list('GlaucusSim' = GlaucusSim,
                     'PhysaliaSim' = PhysaliaSim)
  
  return(simResults)
}

```

## 3.2 Beaching profiles
<p align="justify">
The following code block includes the code used to run 32 simulations in parallel on the HPC. The outputs were stored as csv files: these were used to produce figure 1. I have removed definition of functions and installation commands from this segment, as they are not needed here. For the full, unaltered script, please see the appendix.
</p>
```{r HPC_1, eval=F, include=TRUE}
# step 1: obtain batch number from command line argument:
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 1) { # no arguments provided
  stop("Parameter for batch number needs to be provided.")
} else {
  batch <- as.integer(args[1])
}

#### Model Analyses ####

# Initialise the starting area for the fleet. I
# did not think it made sense to just have them randomly
# throughout the ocean, they should be relatively close
# together to start. We can then see how they diverge.

iniSpace <- list(xmin = 1.1,
                 xmax = 1.11,
                 ymin = 35,
                 ymax = 60)

# Grid spatial extent, each unit represents a kilometer
n_rows <- 100
n_cols <- 100

# Number of simulation iterations
nTimes = 5

# Number of Glaucus and Pysalia individuals
nPhysalia = 600
nGlaucus = 250

# Direction and strength parameters intialisation
dir_wind = (45*pi)/180
dir_current = pi

strength_current = 2

# Dragon Chemodetection. The detection range for a predator.
# These are REALLY small animals, and they are limited in 
# movement. It really is an unknown.
# Parameter in meters. Sensible would be anything up to 1m (km units)
glaucus_Chemodetection <- 0.001

# Dragon speed. How fast can they swim? Again, not much is known
# Reasonable parameter values range between 1-25 cm an hour.
# We add some stochasticity to this in the model.
glaucus_Speed <- 0.00015



BFS <- simBlueFleet.stochPhys(nTimes=nTimes, n_rows = n_rows, n_cols = n_cols, nPhysalia = nPhysalia, nGlaucus = nGlaucus,
                            strength_current = strength_current,
                            dir_wind = dir_wind, dir_current = dir_current, glaucus_Chemodetection = glaucus_Chemodetection,
                            glaucus_Speed = glaucus_Speed, iniSpace = iniSpace)

max.strandings <- data.frame('beached_glaucus' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)),
                             'beached.phys.left' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)),
                             'beached.phys.right' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)))
for(i in 1:length(BFS$GlaucusSim)){

  max.strandings$beached_glaucus[i] <- sum(BFS$GlaucusSim[[i]]$status == 'BEACHED') / nrow(BFS$GlaucusSim[[i]])
  max.strandings$beached.phys.left[i] <- sum(subset(BFS$PhysaliaSim[[i]], orientation == 'left')$status == 'BEACHED') / nrow(subset(BFS$PhysaliaSim[[i]], orientation == 'left'))
  max.strandings$beached.phys.right[i] <- sum(subset(BFS$PhysaliaSim[[i]], orientation == 'right')$status == 'BEACHED') / nrow(subset(BFS$PhysaliaSim[[i]], orientation == 'right'))
  

}

# Return output
write.csv(max.strandings, paste0("BF_simulation_MaxStrandings",batch,".csv"))



```
## 3.3 Hunting behaviour
<p align="justify">
The following code block includes the code needed to run the simulation function over different values of swimming speed and chemodetection range, obtained from an LHS design. The code was run in an HPC environment and the outputs were stored as csv files: these were used to produce figure 2. I have removed definition of functions and installation commands from this segment, as they are not needed here. For the full, unaltered script, please see the appendix.
<p/>
```{r HPC_2, eval=F, include=TRUE}
# step 1: obtain batch number from command line argument:
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 1) { # no arguments provided
  stop("Parameter for batch number needs to be provided.")
} else {
  batch <- as.integer(args[1])
}

# Use batch number to set different densities.
if(batch == 1){
  density<-1
}
if(batch==2){
  density <- 3
}
if(batch==3){
  density <- 5
}

## Read in the pre-made LHS 
LHS<-read.csv('LHS_Hunting_Behaviour.csv')

# Number of predators
nGlaucus = 250

LHS$nGlaucus = nGlaucus

LHS$Total_Attacks <- 0
LHS$Total_LatchTime <- 0
LHS$Total_eaten <- 0
LHS$interaction <- 0
LHS$nPhysalia <- density*nGlaucus
LHS$density <- density

# Initialise the starting area for the fleet. I
# did not think it made sense to just have them randomly
# throughout the ocean, they should be relatively close
# together to start. We can then see how they diverge.

iniSpace <- list(xmin = 8,
                 xmax = 9,
                 ymin = 40,
                 ymax = 41)

# Grid spatial extent, each unit represents a kilometer
n_rows <- 100
n_cols <- 100

# Number of simulation iterations
nTimes = 500

# Direction and strength parameters intialisation
dir_wind = (45*pi)/180
dir_current = pi
strength_current = 2

# Run 50 simulations based on the LHS

for(i in 1:nrow(LHS)){
  print(paste0(i, ' of 50'))
  # Define parameters
  nPhysalia = LHS$nPhysalia[i]
  glaucus_Chemodetection = LHS$glaucus_Chemodetection[i]
  glaucus_Speed = LHS$glaucus_Speed[i]
  
  BFS <- simBlueFleet.stochPhys(nTimes=nTimes, n_rows = n_rows, n_cols = n_cols, nPhysalia = nPhysalia, 
                                nGlaucus = nGlaucus, strength_current = strength_current,
                                dir_wind = dir_wind, dir_current = dir_current, 
                                glaucus_Chemodetection = glaucus_Chemodetection,
                                glaucus_Speed = glaucus_Speed, iniSpace = iniSpace)
  
  
  # how many attacks
  
  LHS$Total_Attacks[i] <- sum(BFS$PhysaliaSim[[nTimes]]$underattack)
  
  LHS$interaction[i] <- sum(BFS$GlaucusSim[[nTimes]]$interaction)
  
  # how many eaten
  LHS$Total_eaten[i] <- sum(BFS$PhysaliaSim[[nTimes]]$status == 'EATEN')
  
  # latch_time
  LHS$Total_LatchTime[i] <- sum(BFS$GlaucusSim[[nTimes]]$total_latch_time)
  
}
  
  
# Return output
write.csv(LHS, paste0("Hunting_Simulations", batch, ".csv"))


  
  


```
# 4. Results

## 4.1 Beaching Probabilities
<p align="justify">
The beaching probabilities for the simulated Blue dragons and Bluebottles are presented in figure 1. Despite randomized starting positions and stochastic individual parameters, all blue dragons eventually ended up beached (Figure 1a). Moreover, the timing at which beaching occurred was similar over all 32 simulation, with the first individuals typically beaching between 75-95 hours into the simulation, and the last individuals between 100-150 hours into the simulation (Figure 1a). Notwithstanding some minor variation between simulations, beaching generally occurred in a single burst over 20-70 hours (1-3 days) - once beaching started, all individuals would soon follow. 
</p>

<p align="justify">
The dynamics of the bluebottles were markedly different to that of the blue dragons. Right sailed bluebottles were especially prone to beaching: all right-sailed individuals became beached within the first 50 hours of the simulation (Figure 1b). This was consistent across simulation replicates. In contrast, left-sailed individuals often avoid beaching altogether in the majority of simulations (Figure 1b). Moreover, once individuals started beaching, this did not always guarantee that all individuals would eventually beach: a big difference compared to left-sailed individuals and the blue dragons.
</p>

```{r plot 1, eval=T, include=T, echo=FALSE,out.width="3000px", fig.cap= '**Figure 1.** Proportion of beached individuals over time. Subplot a) shows beaching proportions for *Glaucus atlanticus*, subplot b) shows beaching proportions for *Physalia physalis*. Each line represents results from a single simulation run over 500 hours (out of 32 total simulations).'}

# Plot 1 Beaching rates
par(mfrow=c(1,2), mar= c(4.5,4,1,1))
# Import output files
simOutput_list <- list()

for(i in 1:32){
  simOutput_list[[i]] <- read_csv(paste0("/Users/sassen/BlueFleet_IBM/Outputs/HPC_Outputs/PhysicalParamSims/BF_simulation_MaxStrandings",i,".csv"))[, c(2,3,4)]
}

# Add legend to top right, outside plot region

plot(simOutput_list[[1]]$beached_glaucus, type = 'n',
     xlab = 'Time (Hours)', ylab = 'Proportion of Beached Glaucus', xlim=c(0,300),ylim=c(0,1))
for(i in 1:32){
 lines(simOutput_list[[i]]$beached_glaucus, col=alpha('steelblue',0.3), lwd = 2)
}

plot(simOutput_list[[1]]$beached.phys.left, type = 'n',ylim=c(0,1),
     xlab = 'Time (Hours)', ylab = 'Proportion of Beached Physalia', xlim=c(0,500))
for(i in 1:32){
  lines(simOutput_list[[i]]$beached.phys.left, col=alpha('purple',0.8), lwd = 2)
  lines(simOutput_list[[i]]$beached.phys.right, col=alpha('blue',0.5), lwd = 2)
}

legend("topright", legend=c("Left-Sailed","Right-Sailed"),cex=0.5, lty=c(1,1), col = c('purple', 'blue'), title="Orientation", bg= 'white')

```

## 4.2 Predator-Prey Interactions

<p align="justify">
The effect of varying swimming speeds and chemodetection ranges on the number of predator-prey interactions is presented in figure 2. It is important to note that an 'interaction'  is defined as prey being in the immediate proximity of a predator, such that a predator can sense it and alters its behavioral movement. There is a strong positive relationship between chemodetection range of the blue dragon and the number of interactions (Figure 2a). This relationship becomes increasingly pronounced at larger prey densities, with the maximum average interactions around 1 per individual (Figure 2a). There is no discernible association between swimming speed of the blue dragon and the number of interactions (Figure 2b). 
</p>

```{r plot 2, eval=T, include=T, echo=FALSE,out.width="3000px", fig.cap='**Figure 2.** The effect of swimming speed and chemodetection range on the number of interactions between *G. atlanticus* and *P. physalis*. Each point represents a single simulation, each with a unique combination of swimming speed and chemodetection range obtained from a latine square sampling design. Colour represents prey density relative to predators. An interaction is defined as prey being in the immediate proximity of a predator, such that a predator can sense it and alters its behavioral movement.'}

par(mfrow=c(1,2), mar= c(4.5,4,1,1))
huntOutput_list <- list()

for(i in 1:3){
  huntOutput_list[[i]] <- read_csv(paste0("/Users/sassen/BlueFleet_IBM/Outputs/HPC_Outputs/HuntingParamSims/Hunting_Simulations",i,".csv"))[,-1]
  huntOutput_list[[i]]$interactionPerInd <- huntOutput_list[[i]]$interaction/huntOutput_list[[i]]$nGlaucus
  huntOutput_list[[i]]$chemoM <- huntOutput_list[[i]]$glaucus_Chemodetection*1000
  huntOutput_list[[i]]$speedM <- huntOutput_list[[i]]$glaucus_Speed*1000
}

plot(interactionPerInd~chemoM,data = huntOutput_list[[3]], pch=19, type = 'n',
     ylab= "Interactions per Individual", xlab = 'Chemodetection Range (m)')
cols <- c('blue', 'red', 'green')
for(i in 1:3){
 points(interactionPerInd~chemoM,data = huntOutput_list[[i]], bg = cols[i], pch=21, col='black')

}
legend('topleft',title = 'Prey Density' ,legend = c('1x','3x', '5x'),cex=0.55, pch = 19,col=c('blue', 'green', 'red'))


plot(interactionPerInd~speedM,data = huntOutput_list[[3]], pch=19, type = 'n',
     ylab= "Interactions per Individual", xlab = 'Swimming Speed (m)')
cols <- c('blue', 'red', 'green')
for(i in 1:3){
  points(interactionPerInd~speedM,data = huntOutput_list[[i]], bg = cols[i], pch=21, col='black')
  
}
legend('topleft',title = 'Prey Density' ,legend = c('1x','3x', '5x'),cex=0.55, pch = 19,col=c('blue', 'green', 'red'))

```

# 5. Conclusion

## 5.1 The Blue Fleet: a loose assemblage?

<p align="justify">
The results from this work show that *G. atlanticus* and *P. physalis* have different probabilities of beaching in our very simple, simulated ocean. Whilst *G. atlanticus* always ended up on the beach, *P. physalis* often avoided beaching due to their intraspecific morphological variation. However, whilst this result provides support for the theory that *P. physalis* having two different sail orientations can help their populations survive a strong onshore wind, it fails to explain why we sometimes observe monospecific beaching events of bluebottles. The results suggests that *G. atlanticus* that come within 10 km of the shoreline, will inevitably beach. Such a conclusion seems unrealistic, however there may be some merit to it. *G. atlanticus* are primarily found far offshore in oceanic gyres systems, where they congregate under the influence of major currents. Perhaps then, when individuals do find themselves close to shore, their morphology simply makes them prone to beaching - assuming a dominant northeasterly wind and south-flowing current. If this were true, *P. physalis* beaching events that lack *G. atlanticus* could be explained by the drifting assemblage consisting solely of *P. physalis*. Alternatively, our model may have simply been to simple: with the wind direction being skewed too heavily towards a northeasterly origin, pushing individuals towards the beach at the western end of the grid. However, our model does provide a valuable exploration of the beaching dynamics of the two species and the fact that there are definite differences between them is an interesting find that could be further built upon.
</p>

## 5.2 Glaucus atlanticus as an active predator?

<p align="justify">
We also investigated the role of swimming speed and chemodetection on the ability of *G. atlanticus* to find prey. Unsurprisingly, the number of predator-prey interactions sharply increased with chemodetection range. The larger the radius of chemodetection, the more likely it is to sense prey. Once prey is sensed, *G. atlanticus* will move towards it, but once the prey item moves out of that zone, the predator is essentially aimless and no interaction is recorded. The lack of a relationship between swimming speed and the number of interactions should then be interpreted as an inability of the predator to 'keep up' with sensed prey. If a predator swims fast enough, it will remain within sensing range of the prey (or, if it is really fast, within feeding range). However, if the prey item is moving too fast due to the effects of physical forces, sensed prey will quickly move of the sensory zone, and the predator once again becomes aimless. Our results show that there is no difference in the number of interactions for swimming speeds of 0, or the complete inability to move towards a goal, and a speed of 20 meters an hour. It is thus likely that most interactions take place at the early stages of the simulation, when individuals are relatively close to one another. Following this early stage, individuals quickly diverge due to their different morphologies - it is at this stage that the predator would need to keep up with prey by swimming at a speed equal to the prey's physically-driven movement. Based on a complete lack of association between swimming speed and interactions, we are comfotable concluding that *G. atlanticus* does not actively hunt prey over larger distances, but probably encounters prey randomly. However, we stress that this conclusion relies heavily on the densities of prey and predators used in our simulations, which were between 250-1250 over the entire grid, in addition to the chosen wind and current regime. In the real world, *G. atlanticus* may produce up to 12,000 embryo's every 12 hours (Helm, 2021). Many neustonic species produce similar numbers of offspring: densities might then be extremely high in certain areas, allowing *G. atlanticus* to increase their interactions with prey by swimming very small distances, especially if those areas have wind and current regimes conducive to concentrating the neuston (i.e. the centers of oceanic gyres). 
</p>

# 6. References

Bourg, N., Schaeffer, A., Cetina-Heredia, P., Lawes, J. C., & Lee, D. (2022). Driving the blue fleet: Temporal variability and drivers behind bluebottle (Physalia physalis) beachings off Sydney, Australia. Plos one, 17(3), e0265593.

Helm, R. R. (2021). Natural history of neustonic animals in the Sargasso Sea: reproduction, predation, and behavior of Glaucus atlanticus, Velella velella, and Janthina spp. Marine Biodiversity, 51(6), 99.

Grove, S. (2010). Blow-ins from the Blue Fleet. The Tasmanian Naturalist, 132, 25-34.

Lee, D., Schaeffer, A., & Groeskamp, S. (2021). Drifting Dynamics of the Bluebottle. Ocean Science Discussions, 2021, 1-21.

Middleton, J. H., Cox, D., & Tate, P. (1996). The oceanography of the Sydney region. Marine Pollution Bulletin, 33(7-12), 124-131.

Valdés, Á., & Campillo, O. A. (2004). Systematics of pelagic aeolid nudibranchs of the family Glaucidae (Mollusca, Gastropoda). Bulletin of Marine Science, 75(3), 381-389.

WillyWeather (2023). 5-year Average Wind Directions. Retrieved at: https://wind.willyweather.com.au/nsw/sydney/sydney.html

# 7. Appendix

I have added the scripts used to obtain all main results here, for the sake of completeness. All scripts, plots and files are also available in the GitHub repository at:
https://github.com/joopie-28/BlueFleet_IBM


### Appendix A. 'Stochastic_Parameter_Run.R' script

```{r beachprob, eval=F, include=TRUE}
#############################################
# Stochastic physical parameters model runs #

# 'Stochastic_Parameter_Run.R' script #

# Install packages
library(units, lib.loc=Sys.getenv("R_LIBS_USER"))
library(rgeos, lib.loc=Sys.getenv("R_LIBS_USER"))
library(tidyverse)
library(sf)
library(data.table)
library(extraDistr, lib.loc=Sys.getenv("R_LIBS_USER"))

# step 1: obtain batch number from command line argument:
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 1) { # no arguments provided
  stop("Parameter for batch number needs to be provided.")
} else {
  batch <- as.integer(args[1])
}


#### 1. Define Functions ####

#### 1. Define Functions ####

# Movement of Physalia
physaliaMovement <- function(physalia, glaucus){
  
  # Boundary conditions for movement, i.e. out of frame
  # stop updating if this happens
  if(physalia$y >= 100 | physalia$y <= 1 |physalia$x >= 100){
    
    return(physalia)}
  
  # Check Physalia is alive and not beached
  if(physalia$x > 1 & physalia$status != 'EATEN'){
    
    ### Predator-prey module
    
    # We want to simulate damage to the physalia, i.e. being killed by a predator.
    # We use a simple rule: if the glaucus is within feeding range of the physalia
    # for 24 hours, the physalia has been eaten completely. The glaucus will then also
    # move on as we assign status 'eaten' to the physalia. 
    
    # Convert to spatial geometries to allow geometric operations.
    spat.point <- st_point(c(physalia$x, physalia$y))
    
    # We can decide what a reasonable buffer is. This is the same for
    # all physalia. 
    under.attack.zone <- st_buffer(spat.point, 0.0005)
    
    # Check if there is a predator nearby
    glaucus.df.spat <- st_as_sf(glaucus , coords = c('x', 'y'))
    
    # Any predators in the detection/eating zone?
    if(any(st_intersects(glaucus.df.spat, under.attack.zone, sparse = F))){
      
      # If yes, the physalia is 'under attack'
      physalia$underattack <- physalia$underattack + 1
    }
    # Check if physalia is eaten 
    if(physalia$underattack >= 24){
      physalia$status <- 'EATEN'
    }
    
    # We have right and left=handed bluebottles
    # They drift in opposite directions - presumably to sustain populations.
    # We need to account for this properly. In addition, we want to add some
    # stochasticity to the movement. This is due to inherent variability
    # in the shape and size of bluebottles, but also due to waves etc.
    
    if(physalia$orientation == 'right') {direction_offset <- rnorm(1,1,0.25)*pi/3} # right-handed drift at 50 degrees from wind direction.
    if(physalia$orientation == 'left') {direction_offset <- rnorm(1,-1,0.25)*pi/3} # left handed drift at ``
    
    # Positional update rules:
    # Wind has a larger impact on physalia due to the sail
    # physalia also have an offset - their sails change the way they interact with wind. 
    # We also assume current has a slightly smaller effect on them than on glaucus
    
    # 0.0266 - see Lee, Schaeffer, Groeskamp (2021) for justification.
    physalia$x <- physalia$x + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * sin(wind_direction[ceiling(physalia$y), 
                                                                                                ceiling(physalia$x)]+ direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * sin(current_direction[ceiling(physalia$y), 
                                                                           ceiling(physalia$x)])
    
    # Y movement (north - south) uses cosine function
    physalia$y <- physalia$y + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * cos(wind_direction[ceiling(physalia$y), 
                                                                                                ceiling(physalia$x)] + direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * cos(current_direction[ceiling(physalia$y), 
                                                                           ceiling(physalia$x)])
    
  } else{
    
    # Check if individual is beached
    if(physalia$x <= 1){
      physalia$status <- 'BEACHED'
    }
  }
  return(physalia)
}

# Movement of Glaucus: depends on an individual glaucus and the physalia fleet
glaucusMovement <- function(glaucus, physalia){
  
  # Boundary conditions for movement, i.e. out of frame.
  # stop updating if this is the case
  if(glaucus$y >= 100 | glaucus$y <= 1 | glaucus$x >= 10){ 
    return(glaucus)}
  
  # First check if glaucus are 'latched on' to physalia which will 
  # affect their movement. The physalia has to be alive.
  if(!is.na(glaucus$target_ID) & physalia[glaucus$target_ID,'status'][1] != 'EATEN'){
    glaucus$x <- physalia[glaucus$target_ID,'x']
    glaucus$y <- physalia[glaucus$target_ID,'y']
    glaucus$latch_time <- glaucus$latch_time + 1
    glaucus$total_latch_time <- glaucus$total_latch_time + 1
    
    # Probability of glaucus detaching follows a beta prime distribution.
    # Shape of distribtution set to match expected behaviour - though arbitrary.
    
    probs <- c(1-pbetapr(glaucus$latch_time, 24, 5), pbetapr(glaucus$latch_time, 24, 5))
    glaucus$target_ID <- sample(size=1, x = c(glaucus$target_ID, NA), prob = probs) # NA corresponds to letting go of prey.
    
  }else{
    
    
    # Check the Glaucus is not beached, if OK, proceed with movement update
    # as effect of physical forces
    if(glaucus$x > 1){
      
      # Positional update rules: movement of a Glaucus
      # We use ceiling() to round up and extract force values from the grids.
      # The grids are set globally prior to function call.
      glaucus$x <- glaucus$x + 0.01*wind_strength[ceiling(glaucus$y), 
                                                  ceiling(glaucus$x)] * sin(wind_direction[ceiling(glaucus$y), 
                                                                                           ceiling(glaucus$x)])+
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * sin(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      # Y movement (north - south) uses cosine function
      glaucus$y <- glaucus$y + 0.01*wind_strength[ceiling(glaucus$y), 
                                                  ceiling(glaucus$x)] * cos(wind_direction[ceiling(glaucus$y), 
                                                                                           ceiling(glaucus$x)]) +
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * cos(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      ### Predator module - handles the predator behaviour
      
      # Glaucus are predators. They can detect prey from distance using chemical cues. We want to simulate these capabilities
      # by allowing glaucus limited movement to a target, if the target is within reasonable range.
      
      # scan area for each glaucus
      # Convert to spatial geometries to allow geometric operations.
      spat.point <- st_point(c(glaucus$x, glaucus$y))
      
      # Chemodetection range calculated as circle with radius equal to 
      # the predetermined parameter.
      detection.zone <- st_buffer(spat.point, glaucus$chemodetection)
      
      # Find the Physalia that are within the detection zone.
      physalia.df.spat <- st_as_sf(physalia , coords = c('x', 'y'))
      
      # Any prey in the detection zone?
      if(any(st_intersects(physalia.df.spat, detection.zone, sparse = F))){
        # Find the nearest Physalia
        print('Attack!') # to check if all is ok
        
        # extract some info on the prey
        glaucus.target <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'geometry']]
        glaucus.target.id <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'ID']]
        
        # Now make it move towards the target. We just assume it 
        # is quite good at sensing prey so its movement is 
        # directed.
        
        target_angle <- atan2(glaucus.target[2] - glaucus$y, glaucus.target[1] - glaucus$x) # atan2 calculates the angle to get from y to x
        glaucus$x <- glaucus$x + glaucus$speed * cos(target_angle) 
        glaucus$y <- glaucus$y +  glaucus$speed * sin(target_angle)
        
        # track interaction - defined as entities being close enough to change behaviour 
        # i.e. sensing, eating, latching
        glaucus$interaction <- as.numeric(glaucus$interaction) + 1
        
        # Latch-on module
        eating.zone <- st_buffer(spat.point, 0.0005) 
        if(st_intersects(physalia.df.spat[glaucus.target.id,], eating.zone, sparse = F)){
          print('LATCHED')
          
          # Identify the prey to latch on and store as glaucus attribute
          glaucus$target_ID <- glaucus.target.id 
          
        }
      }
      
      
    } else{
      glaucus$status <- 'BEACHED' # glaucus is beached
    }
  }
  return(glaucus)
}

# Stochastic parameter wind strength
wind_strength_calc <-function(hour) {
  # Parameters for the sinusoidal function
  peak_hour <- 20        # Hour of the day with maximum wind
  amplitude <- 5       # Amplitude of the sinusoidal function (half of the variation)
  
  
  # Calculate daylight hours using a sinusoidal function
  strength = amplitude * sin((hour - peak_hour) * 2 * pi / 24) + 10 
  strength = (strength + rnorm(length(hour), 0, sd = 3))
  strength[which(strength<0)] <- 0
  return(strength)
}

# Simulation version that allows wind and current directions to vary stochastically at each timestep.
simBlueFleet.stochPhys <- function(nTimes,n_rows, n_cols, nPhysalia, nGlaucus,
                                   strength_current,
                                   dir_wind, dir_current,
                                   glaucus_Chemodetection, glaucus_Speed, iniSpace){
  
  # Assign wind and current speed and direction to each grid cell.
  # Based on param input
  current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                              nrow=n_rows)
  
  # Wind and current directions
  
  wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                            nrow=n_rows, ncol=n_cols)
  current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                               nrow=n_rows, ncol=n_cols)
  
  
  ### Instantiate model agents
  
  # Glaucus atlanticus individuals
  print('Generating animals')
  # Our individuals also have attributes. Glaucus are our predators.
  # They will seek out Physalia, and are capable of (very limited)
  # powered movement. 
  
  glaucus <- data.frame(matrix(nrow=nGlaucus, ncol=10))
  colnames(glaucus) <- c("ID", "x", "y", "chemodetection", "speed", "latch_time","total_latch_time", "target_ID", "interaction", "status")
  for (i in 1:nGlaucus) {
    glaucus[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      chemodetection = rnorm(1, glaucus_Chemodetection, glaucus_Chemodetection/4), 
      speed = rnorm(1,glaucus_Speed, sd = glaucus_Speed/4),
      latch_time = 0,
      total_latch_time = 0,
      target_ID = NA,
      interaction = 0,
      status = 'ALIVE'
    )
  }
  
  # Set up bluebottle movement and functions. Bluebottles can be right
  # or left handed.
  physalia <- data.frame(matrix(nrow=nPhysalia, ncol=6))
  colnames(physalia) <- c("ID", "x", "y", "underattack", "status", "orientation")
  
  for (i in 1:nPhysalia) {
    physalia[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      underattack = 0,
      status = 'ALIVE',
      orientation = sample(c('left', 'right'),1)
    )
  }
  
  print('Simulating Dynamics')
  GlaucusSim <- list()
  PhysaliaSim <- list()
  
  # Run model over nTimes steps.
  for (i in 1:nTimes){
    print(i)
    wind_strength <<- matrix(rep(wind_strength_calc(i),n_rows*n_cols), 
                             nrow=n_rows)
    # Wind and current directions vary each hour, but within boundaries
    dir_wind = ifelse(rnorm(1, dir_wind, 0.1) > 1.75*pi, 1.75*pi, 
                      ifelse(rnorm(1, dir_wind, 0.1) < 1.25*pi, 1.25*pi,
                             rnorm(1, dir_wind, 0.1))) |> sin()
      
    
    dir_current = ifelse(rnorm(1, dir_current, 0.1) > 3.5, 3.5, 
                         ifelse(rnorm(1, dir_current, 0.1) < 2.9, 2.9,
                                rnorm(1, dir_current, 0.1)))
    
    strength_current = ifelse(rnorm(1, strength_current, 0.1) > 7, 7, 
                         ifelse(rnorm(1, strength_current, 0.1) < 2, 2,
                                rnorm(1, strength_current, 0.1)))
    
    wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                              nrow=n_rows, ncol=n_cols)
    current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                                 nrow=n_rows, ncol=n_cols)
    current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                                nrow=n_rows)
    
    # Update Physalia movement
    for(k in 1:nPhysalia){
      
      # This function updates the position of all simulated
      # Physalia. Also tracks their 'status', which may be one
      # of 'ALIVE', 'BEACHED', or 'EATEN'.
      physalia[k, ] <- physaliaMovement(physalia[k,], glaucus)
    }
    
    PhysaliaSim[[i]] <- physalia
    
    
    # Update Glaucus movement. Status includes 'BEACHED' or 'ALIVE'.
    for(j in 1:nGlaucus){
      glaucus[j,] <- glaucusMovement(glaucus[j,], physalia)
      
    }
    GlaucusSim[[i]] <- glaucus
  }
  simResults <- list('GlaucusSim' = GlaucusSim,
                     'PhysaliaSim' = PhysaliaSim)
  
  return(simResults)
}

#### Model Analyses ####

# Initialise the starting area for the fleet. I
# did not think it made sense to just have them randomly
# throughout the ocean, they should be relatively close
# together to start. We can then see how they diverge.

iniSpace <- list(xmin = 1.1,
                 xmax = 1.11,
                 ymin = 35,
                 ymax = 60)

# Grid spatial extent, each unit represents a kilometer
n_rows <- 100
n_cols <- 100

# Number of simulation iterations
nTimes = 5

# Number of Glaucus and Pysalia individuals
nPhysalia = 600
nGlaucus = 250

# Direction and strength parameters intialisation
dir_wind = ((360-45)*pi)/180
dir_current = pi

strength_current = 5

# Dragon Chemodetection. The detection range for a predator.
# These are REALLY small animals, and they are limited in 
# movement. It really is an unknown.
# Parameter in meters. Sensible would be anything up to 1m (km units)
glaucus_Chemodetection <- 0.001

# Dragon speed. How fast can they swim? Again, not much is known
# Reasonable parameter values range between 1-25 cm an hour.
# We add some stochasticity to this in the model.
glaucus_Speed <- 0.00015



BFS <- simBlueFleet.stochPhys(nTimes=nTimes, n_rows = n_rows, n_cols = n_cols, nPhysalia = nPhysalia, nGlaucus = nGlaucus,
                            strength_current = strength_current,
                            dir_wind = dir_wind, dir_current = dir_current, glaucus_Chemodetection = glaucus_Chemodetection,
                            glaucus_Speed = glaucus_Speed, iniSpace = iniSpace)

max.strandings <- data.frame('beached_glaucus' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)),
                             'beached.phys.left' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)),
                             'beached.phys.right' = vector(mode = 'numeric', length=length(BFS$GlaucusSim)))
for(i in 1:length(BFS$GlaucusSim)){

  max.strandings$beached_glaucus[i] <- sum(BFS$GlaucusSim[[i]]$status == 'BEACHED') / nrow(BFS$GlaucusSim[[i]])
  max.strandings$beached.phys.left[i] <- sum(subset(BFS$PhysaliaSim[[i]], orientation == 'left')$status == 'BEACHED') / nrow(subset(BFS$PhysaliaSim[[i]], orientation == 'left'))
  max.strandings$beached.phys.right[i] <- sum(subset(BFS$PhysaliaSim[[i]], orientation == 'right')$status == 'BEACHED') / nrow(subset(BFS$PhysaliaSim[[i]], orientation == 'right'))
  

}

# Return output
write.csv(max.strandings, paste0("BF_simulation_MaxStrandings",batch,".csv"))



```

### Appendix B. 'Hunting_Behaviour_Run.R' script
```{r huntinginteractions, eval=F, include=TRUE}

#### Understanding hunting behaviour ###

# 'Hunting_Behaviour_Run.R' script

# Install packages
library(units, lib.loc=Sys.getenv("R_LIBS_USER"))
library(rgeos, lib.loc=Sys.getenv("R_LIBS_USER"))
library(tidyverse)
library(sf)
library(data.table)
library(extraDistr, lib.loc=Sys.getenv("R_LIBS_USER"))



#### 1. Define Functions ####

# Movement of Physalia
physaliaMovement <- function(physalia, glaucus){
  
  # Boundary conditions for movement, i.e. out of frame
  # stop updating if this happens
  if(physalia$y >= 100 | physalia$y <= 1 |physalia$x >= 100){
    
    return(physalia)}
  
  # Check Physalia is alive and not beached
  if(physalia$x > 1 & physalia$status != 'EATEN'){
    
    ### Predator-prey module
    
    # We want to simulate damage to the physalia, i.e. being killed by a predator.
    # We use a simple rule: if the glaucus is within feeding range of the physalia
    # for 24 hours, the physalia has been eaten completely. The glaucus will then also
    # move on as we assign status 'eaten' to the physalia. 
    
    # Convert to spatial geometries to allow geometric operations.
    spat.point <- st_point(c(physalia$x, physalia$y))
    
    # We can decide what a reasonable buffer is. This is the same for
    # all physalia. 
    under.attack.zone <- st_buffer(spat.point, 0.0005)
    
    # Check if there is a predator nearby
    glaucus.df.spat <- st_as_sf(glaucus , coords = c('x', 'y'))
    
    # Any predators in the detection/eating zone?
    if(any(st_intersects(glaucus.df.spat, under.attack.zone, sparse = F))){
      
      # If yes, the physalia is 'under attack'
      physalia$underattack <- physalia$underattack + 1
    }
    # Check if physalia is eaten 
    if(physalia$underattack >= 24){
      physalia$status <- 'EATEN'
    }
    
    # We have right and left=handed bluebottles
    # They drift in opposite directions - presumably to sustain populations.
    # We need to account for this properly. In addition, we want to add some
    # stochasticity to the movement. This is due to inherent variability
    # in the shape and size of bluebottles, but also due to waves etc.
    
    if(physalia$orientation == 'right') {direction_offset <- rnorm(1,1,0.25)*pi/3} # right-handed drift at 50 degrees from wind direction.
    if(physalia$orientation == 'left') {direction_offset <- rnorm(1,-1,0.25)*pi/3} # left handed drift at ``
    
    # Positional update rules:
    # Wind has a larger impact on physalia due to the sail
    # physalia also have an offset - their sails change the way they interact with wind. 
    # We also assume current has a slightly smaller effect on them than on glaucus
    
    # 0.0266 - see Lee, Schaeffer, Groeskamp (2021) for justification.
    physalia$x <- physalia$x + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * sin(wind_direction[ceiling(physalia$y), 
                                                                                                ceiling(physalia$x)]+ direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * sin(current_direction[ceiling(physalia$y), 
                                                                           ceiling(physalia$x)])
    
    # Y movement (north - south) uses cosine function
    physalia$y <- physalia$y + 0.0266*(wind_strength[ceiling(physalia$y), 
                                                     ceiling(physalia$x)]) * cos(wind_direction[ceiling(physalia$y), 
                                                                                                ceiling(physalia$x)] + direction_offset) +
      0.001* current_strength[ceiling(physalia$y), 
                              ceiling(physalia$x)] * cos(current_direction[ceiling(physalia$y), 
                                                                           ceiling(physalia$x)])
    
  } else{
    
    # Check if individual is beached
    if(physalia$x <= 1){
      physalia$status <- 'BEACHED'
    }
  }
  return(physalia)
}

# Movement of Glaucus with extra interaction
glaucusMovement <- function(glaucus, physalia){
  
  # Boundary conditions for movement, i.e. out of frame.
  # stop updating if this is the case
  if(glaucus$y >= 100 | glaucus$y <= 1 | glaucus$x >= 10){ 
    return(glaucus)}
  
  # First check if glaucus are 'latched on' to physalia which will 
  # affect their movement. The physalia has to be alive.
  if(!is.na(glaucus$target_ID) & physalia[glaucus$target_ID,'status'][1] != 'EATEN'){
    glaucus$x <- physalia[glaucus$target_ID,'x']
    glaucus$y <- physalia[glaucus$target_ID,'y']
    glaucus$latch_time <- glaucus$latch_time + 1
    glaucus$total_latch_time <- glaucus$total_latch_time + 1
    
    # Probability of glaucus detaching follows a beta prime distribution.
    # Shape of distribtution set to match expected behaviour - though arbitrary.
    
    probs <- c(1-pbetapr(glaucus$latch_time, 24, 5), pbetapr(glaucus$latch_time, 24, 5))
    glaucus$target_ID <- sample(size=1, x = c(glaucus$target_ID, NA), prob = probs) # NA corresponds to letting go of prey.
    
  }else{
    
    
    # Check the Glaucus is not beached, if OK, proceed with movement update
    # as effect of physical forces
    if(glaucus$x > 1){
      
      # Positional update rules: movement of a Glaucus
      # We use ceiling() to round up and extract force values from the grids.
      # The grids are set globally prior to function call.
      glaucus$x <- glaucus$x + 0.01*wind_strength[ceiling(glaucus$y), 
                                                  ceiling(glaucus$x)] * sin(wind_direction[ceiling(glaucus$y), 
                                                                                           ceiling(glaucus$x)])+
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * sin(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      # Y movement (north - south) uses cosine function
      glaucus$y <- glaucus$y + 0.01*wind_strength[ceiling(glaucus$y), 
                                                  ceiling(glaucus$x)] * cos(wind_direction[ceiling(glaucus$y), 
                                                                                           ceiling(glaucus$x)]) +
        0.005 * current_strength[ceiling(glaucus$y), 
                                 ceiling(glaucus$x)] * cos(current_direction[ceiling(glaucus$y), 
                                                                             ceiling(glaucus$x)])
      
      ### Predator module - handles the predator behaviour
      
      # Glaucus are predators. They can detect prey from distance using chemical cues. We want to simulate these capabilities
      # by allowing glaucus limited movement to a target, if the target is within reasonable range.
      
      # scan area for each glaucus
      # Convert to spatial geometries to allow geometric operations.
      spat.point <- st_point(c(glaucus$x, glaucus$y))
      
      # Chemodetection range calculated as circle with radius equal to 
      # the predetermined parameter.
      detection.zone <- st_buffer(spat.point, glaucus$chemodetection)
      
      # Find the Physalia that are within the detection zone.
      physalia.df.spat <- st_as_sf(physalia , coords = c('x', 'y'))
      
      # Any prey in the detection zone?
      if(any(st_intersects(physalia.df.spat, detection.zone, sparse = F))){
        # Find the nearest Physalia
        print('Attack!') # to check if all is ok
        
        # extract some info on the prey
        glaucus.target <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'geometry']]
        glaucus.target.id <- physalia.df.spat[[which.min(st_distance(spat.point, physalia.df.spat)),'ID']]
        
        # Now make it move towards the target. We just assume it 
        # is quite good at sensing prey so its movement is 
        # directed.
        
        target_angle <- atan2(glaucus.target[2] - glaucus$y, glaucus.target[1] - glaucus$x) # atan2 calculates the angle to get from y to x
        glaucus$x <- glaucus$x + glaucus$speed * cos(target_angle) 
        glaucus$y <- glaucus$y +  glaucus$speed * sin(target_angle)
        
        # track interaction - defined as entities being close enough to change behaviour 
        # i.e. sensing, eating, latching
        glaucus$interaction <- as.numeric(glaucus$interaction) + 1
        
        # Latch-on module
        eating.zone <- st_buffer(spat.point, 0.0005) 
        if(st_intersects(physalia.df.spat[glaucus.target.id,], eating.zone, sparse = F)){
          print('LATCHED')
          
          # Identify the prey to latch on and store as glaucus attribute
          glaucus$target_ID <- glaucus.target.id 
          
        }
      }
      
      
    } else{
      glaucus$status <- 'BEACHED' # glaucus is beached
    }
  }
  return(glaucus)
}

# Stochastic parameter wind strength
wind_strength_calc <-function(hour) {
  # Parameters for the sinusoidal function
  peak_hour <- 20        # Hour of the day with maximum wind
  amplitude <- 5       # Amplitude of the sinusoidal function (half of the variation)
  
  
  # Calculate daylight hours using a sinusoidal function
  strength = amplitude * sin((hour - peak_hour) * 2 * pi / 24) + 10 
  strength = (strength + rnorm(length(hour), 0, sd = 3))
  strength[which(strength<0)] <- 0
  return(strength)
}

# Simulation version that allows wind and current directions to vary stochastically at each timestep.
simBlueFleet.stochPhys <- function(nTimes,n_rows, n_cols, nPhysalia, nGlaucus,
                                   strength_current,
                                   dir_wind, dir_current,
                                   glaucus_Chemodetection, glaucus_Speed, iniSpace){
  
  # Assign wind and current speed and direction to each grid cell.
  # Based on param input
  current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                              nrow=n_rows)
  
  # Wind and current directions
  
  wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                            nrow=n_rows, ncol=n_cols)
  current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                               nrow=n_rows, ncol=n_cols)
  
  
  ### Instantiate model agents
  
  # Glaucus atlanticus individuals
  print('Generating animals')
  # Our individuals also have attributes. Glaucus are our predators.
  # They will seek out Physalia, and are capable of (very limited)
  # powered movement. 
  
  glaucus <- data.frame(matrix(nrow=nGlaucus, ncol=10))
  colnames(glaucus) <- c("ID", "x", "y", "chemodetection", "speed", "latch_time","total_latch_time", "target_ID", "interaction", "status")
  for (i in 1:nGlaucus) {
    glaucus[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      chemodetection = rnorm(1, glaucus_Chemodetection, glaucus_Chemodetection/4), 
      speed = rnorm(1,glaucus_Speed, sd = glaucus_Speed/4),
      latch_time = 0,
      total_latch_time = 0,
      target_ID = NA,
      interaction = 0,
      status = 'ALIVE'
    )
  }
  
  # Set up bluebottle movement and functions. Bluebottles can be right
  # or left handed.
  physalia <- data.frame(matrix(nrow=nPhysalia, ncol=6))
  colnames(physalia) <- c("ID", "x", "y", "underattack", "status", "orientation")
  
  for (i in 1:nPhysalia) {
    physalia[i,] <- list(
      ID = i,
      x = round(runif(1, iniSpace$xmin, iniSpace$xmax),3),
      y = round(runif(1, iniSpace$ymin, iniSpace$ymax),3),
      underattack = 0,
      status = 'ALIVE',
      orientation = sample(c('left', 'right'),1)
    )
  }
  
  print('Simulating Dynamics')
  GlaucusSim <- list()
  PhysaliaSim <- list()
  
  # Run model over nTimes steps.
  for (i in 1:nTimes){
    print(i)
    wind_strength <<- matrix(rep(wind_strength_calc(i),n_rows*n_cols), 
                             nrow=n_rows)
    # Wind and current directions vary each hour, but within boundaries
    dir_wind = ifelse(rnorm(1, dir_wind, 0.1) > 1.75*pi, 1.75*pi, 
                      ifelse(rnorm(1, dir_wind, 0.1) < 1.25*pi, 1.25*pi,
                             rnorm(1, dir_wind, 0.1))) |> sin()
    
    
    dir_current = ifelse(rnorm(1, dir_current, 0.1) > 3.5, 3.5, 
                         ifelse(rnorm(1, dir_current, 0.1) < 2.9, 2.9,
                                rnorm(1, dir_current, 0.1)))
    
    strength_current = ifelse(rnorm(1, strength_current, 0.1) > 7, 7, 
                              ifelse(rnorm(1, strength_current, 0.1) < 2, 2,
                                     rnorm(1, strength_current, 0.1)))
    
    wind_direction <<- matrix(rep(dir_wind, n_rows*n_cols), 
                              nrow=n_rows, ncol=n_cols)
    current_direction <<- matrix(rep(dir_current, n_rows*n_cols), 
                                 nrow=n_rows, ncol=n_cols)
    current_strength <<- matrix(rep(strength_current,n_rows*n_cols), 
                                nrow=n_rows)
    
    # Update Physalia movement
    for(k in 1:nPhysalia){
      
      # This function updates the position of all simulated
      # Physalia. Also tracks their 'status', which may be one
      # of 'ALIVE', 'BEACHED', or 'EATEN'.
      physalia[k, ] <- physaliaMovement(physalia[k,], glaucus)
    }
    
    PhysaliaSim[[i]] <- physalia
    
    
    # Update Glaucus movement. Status includes 'BEACHED' or 'ALIVE'.
    for(j in 1:nGlaucus){
      glaucus[j,] <- glaucusMovement(glaucus[j,], physalia)
      
    }
    GlaucusSim[[i]] <- glaucus
  }
  simResults <- list('GlaucusSim' = GlaucusSim,
                     'PhysaliaSim' = PhysaliaSim)
  
  return(simResults)
}

# step 1: obtain batch number from command line argument:
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 1) { # no arguments provided
  stop("Parameter for batch number needs to be provided.")
} else {
  batch <- as.integer(args[1])
}

# Use batch number to set different densities.
if(batch == 1){
  density<-1
}
if(batch==2){
  density <- 3
}
if(batch==3){
  density <- 5
}

## Read in the pre-made LHS 
LHS<-read.csv('LHS_Hunting_Behaviour.csv')

# Number of predators
nGlaucus = 250

LHS$nGlaucus = nGlaucus

LHS$Total_Attacks <- 0
LHS$Total_LatchTime <- 0
LHS$Total_eaten <- 0
LHS$interaction <- 0
LHS$nPhysalia <- density*nGlaucus
LHS$density <- density

# Initialise the starting area for the fleet. I
# did not think it made sense to just have them randomly
# throughout the ocean, they should be relatively close
# together to start. We can then see how they diverge.

iniSpace <- list(xmin = 8,
                 xmax = 9,
                 ymin = 40,
                 ymax = 41)

# Grid spatial extent, each unit represents a kilometer
n_rows <- 100
n_cols <- 100

# Number of simulation iterations
nTimes = 500

# Direction and strength parameters intialisation
dir_wind = ((360-45)*pi)/180
dir_current = pi
strength_current = 5

# Run 50 simulations based on the LHS

for(i in 1:nrow(LHS)){
  print(paste0(i, ' of 50'))
  # Define parameters
  nPhysalia = LHS$nPhysalia[i]
  glaucus_Chemodetection = LHS$glaucus_Chemodetection[i]
  glaucus_Speed = LHS$glaucus_Speed[i]
  
  BFS <- simBlueFleet.stochPhys(nTimes=nTimes, n_rows = n_rows, n_cols = n_cols, nPhysalia = nPhysalia, 
                                nGlaucus = nGlaucus, strength_current = strength_current,
                                dir_wind = dir_wind, dir_current = dir_current, 
                                glaucus_Chemodetection = glaucus_Chemodetection,
                                glaucus_Speed = glaucus_Speed, iniSpace = iniSpace)
  
  
  # how many attacks
  
  LHS$Total_Attacks[i] <- sum(BFS$PhysaliaSim[[nTimes]]$underattack)
  
  LHS$interaction[i] <- sum(BFS$GlaucusSim[[nTimes]]$interaction)
  
  # how many eaten
  LHS$Total_eaten[i] <- sum(BFS$PhysaliaSim[[nTimes]]$status == 'EATEN')
  
  # latch_time
  LHS$Total_LatchTime[i] <- sum(BFS$GlaucusSim[[nTimes]]$total_latch_time)
  
}
  
  
# Return output
write.csv(LHS, paste0("Hunting_Simulations", batch, ".csv"))


  
  



```





### Appendix C. Bash Script for 'Stochastic_Parameter_Run.R' HPC submission
```{bash bashHP1, eval=F, include=TRUE}
#!/bin/bash
#SBATCH --job-name=ScreenParams
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=1
#SBATCH --partition=qbiol
#SBATCH --mem=2GB              # memory (MB)
#SBATCH --time=1-00:00          # time (D-HH:MM)
#SBATCH -o MyJob.%N.%j.out     # STDOUT
#SBATCH -e MyJob.%N.%j.err     # STDERR

#SBATCH --array=1-32

echo "Start time: "; date

module load applications/R/4.0.3

Rscript --vanilla Stochastic_Parameter_Run.R $SLURM_ARRAY_TASK_ID

echo "End time: "; date
```
### Appendix D. Bash Script for 'Hunting_Behaviour_Run.R' HPC submission
```{bash bashHP2, eval=F, include=TRUE}
#!/bin/bash
#SBATCH --job-name=ScreenParams
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=1
#SBATCH --partition=qbiol
#SBATCH --mem=2GB              # memory (MB)
#SBATCH --time=1-00:00          # time (D-HH:MM)
#SBATCH -o MyJob.%N.%j.out     # STDOUT
#SBATCH -e MyJob.%N.%j.err     # STDERR

#SBATCH --array=1-3

echo "Start time: "; date

module load applications/R/4.0.3

Rscript --vanilla Hunting_Behaviour_Run.R $SLURM_ARRAY_TASK_ID

echo "End time: "; date
```
### Appendix E. R script for LHS design
```{r LHSdesign, eval=F, include=TRUE}
#### Creating a latin hypercube sampling design

# we run a combination of densities, swimming speed and chemodetection ranges
library(DoE.wrapper)


Hunting.LHS <- lhs.design(seed = 42,
  nruns = 50,
  nfactors = 2,
  type = "maximin",
  digits = c(8,8),
  factor.names = list(
    "glaucus_Chemodetection" = c(0, 0.02),
    "glaucus_Speed" = c(0, 0.02)))

write_csv(Hunting.LHS, './Outputs/LHS_Hunting_Behaviour.csv')
```
