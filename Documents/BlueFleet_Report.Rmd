---
title: "Predator, prey and strandings: An IBM approach to modelling the 'Blue Fleet'"
author: "J.M. Sassen"
date: "`r Sys.Date()`"
output: html_document
---

![](./Images/BlueFleet_Image_ABC.jpeg)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, incl = T)

```

## Introduction

```{r cars, eval =T}

```

## Movement Equations

The main purpose of this model is to simulate the drifting patterns of two members of the Blue Fleet. The distribution of these animals is mainly driven by winds and currents. 

### Glaucus atlanticus
$$
X_{ij+1} = X_{ij} + WindSpeed_{{xy,i}} * sin(WindDirection_{xy,i}) + CurrentSpeed_{xy,i} * sin(CurrentDirection_{xy,i}) + C * (GlaucusSpeed_{ij} * sin(atan(Y_{Prey} - Y_i, X_{Prey} - X_i)))
$$
$$
Y_{ij+1} = Y_{ij} + WindSpeed_{{xy,i}} * cos(WindDirection_{xy,i}) + CurrentSpeed_{xy,i} * cos(CurrentDirection_{xy,i}) + C * (GlaucusSpeed_{ij} * cos(atan(Y_{Prey} - Y_{ij}, X_{Prey} - X_{ij} )) )
$$
***Where:*** 

$$
X_{ij+1} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
X_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{ij+1} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
Y_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
WindSpeed_{xy,i} = \text{Wind Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
WindDirection_{xy,i} = \text{Wind Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentSpeed_{xy,i} = \text{Current Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentDirection_{xy,i} = \text{Current Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
GlaucusSpeed_{i,j} = \text{Swimming Speed}\,\text{for}\, Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{prey} = \text{Y coordinate of closest prey for}\, Individual_{j } \text{ at Time = } i \\
X_{prey} = \text{X coordinate of closest prey for}\, Individual_{j } \text{ at Time = } i \\
C = \begin{cases}
1, & \text{if Prey within } Detection Range_j \\
0, & \text{if Prey beyond } Detection Range_j
\end{cases}
$$



```{r GA Movement, eval = F, incl = T}
# Movement of Glaucus
glaucusMovement <- function(glaucus, physalia){
  
  # Check the glaucus is not beached
  if(glaucus$x > 1){
    glaucus$col <- 'steelblue'
    
    
    ### Predator module
    
    # Glaucus are predators. They can detect prey from distance using chemical cues. We want to simulate these capabilities
    # by allowing glaucus limited movement to a target, if the target is within reasonable range.
    
    # scan area for each glaucus
    # Convert to spatial geometries to allow geometric operations.
    spat.point <- st_point(c(glaucus$x, glaucus$y))
    
    # We can decide what a reasonable buffer is. This might be a parameter tied to the 
    # individual Glaucus!
    detection.zone <- st_buffer(spat.point, glaucus$chemodetection)

    # Find the Physalia that are within the detection zone.
    # needs to be in df format!!!1 vectorise all at once.
    
    physalia.df <- rbindlist(physalia, fill = T)
    
    physalia.df.spat <- st_as_sf(physalia.df , coords = c('x', 'y'))
    
    # Any prey in the detection zone?
    if(any(st_intersects(physalia.df.spat, detection.zone, sparse = F))){
      # Find the nearest Physalia
      print('Attack!')
      glaucus.target <- physalia.df.spat[[st_nearest_feature(spat.point, physalia.df.spat),'geometry']]
      # Now make it move towards the target. We want to use a random walk-esque
      # movement with bias towards the physalia.
      
      target_angle <- atan2(glaucus.target[2] - glaucus$y, glaucus.target[1] - glaucus$x) # atan2 calculates the angle to get from y to x
      glaucus$x <- glaucus$x + glaucus$speed * sin(target_angle)
      glaucus$y <- glaucus$y +  glaucus$speed * cos(target_angle)
      
    }

  
    # Now account for effect of current and wind on glaucus.  
    
    # Positional update rules: this IS the movement of a Glaucus
    glaucus$x <- max(glaucus$x + 0.005*wind_strength[round(glaucus$x,digits = 2), 
                                               round(glaucus$y, digits = 2)] * sin(wind_direction[round(glaucus$x,digits = 2), 
                                                                                                  round(glaucus$y, digits = 2)]) +
                       current_strength[round(glaucus$x,digits = 2), 
                                        round(glaucus$y, digits = 2)] * sin(current_direction[round(glaucus$x,digits = 2), 
                                                                                              round(glaucus$y, digits = 2)]),0)
    
    # Y movement (north - south) uses cosine function
    glaucus$y <- max(glaucus$y + 0.005*wind_strength[round(glaucus$x,digits = 2), 
                                               round(glaucus$y, digits = 2)] * cos(wind_direction[round(glaucus$x,digits = 2), 
                                                                                                  round(glaucus$y, digits = 2)]) +
                       current_strength[round(glaucus$x,digits = 2), 
                                        round(glaucus$y, digits = 2)] * cos(current_direction[round(glaucus$x,digits = 2), 
                                                                                              round(glaucus$y, digits = 2)]),0)
    
  } else{
    glaucus$col <- 'red'
    glaucus$status <- 'BEACHED' # status 1 is beached
  }
  return(glaucus)
}
```
<br>

### Physalia physalis
$$
X_{ij+1} = X_{ij} + 0.0266*(WindSpeed_{{xy,i}} * sin(WindDirection_{xy,i})) + CurrentSpeed_{xy,i} * sin(CurrentDirection_{xy,i} + D_{ij})) \\
Y_{ij+1} = Y_{ij} + 0.0266*(WindSpeed_{{xy,i}} * cos(WindDirection_{xy,i})) + CurrentSpeed_{xy,i} * cos(CurrentDirection_{xy,i} + D_{ij})
$$
***Where:*** 
$$
X_{ij+1} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
X_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{East-West}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
Y_{ij+1} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i+1 \\
Y_{ij} = \text{Position}\,\text{along}\,\text{the}\,\text{North-South}\,\text{Axis for}\,Individual_{j }\text{ at}\,\text{Time = }\,i \\
WindSpeed_{xy,i} = \text{Wind Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
WindDirection_{xy,i} = \text{Wind Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentSpeed_{xy,i} = \text{Current Speed}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
CurrentDirection_{xy,i} = \text{Current Direction}\,\text{in}\, cell_{X_i,Y_i},\text{at}\,\text{Time = }\,i \\
D_{ij} = \begin{cases}
normal(pi/3, 0.1), & \text{if Orientation}_j = Right \\
normal(-pi/3,0.1), & \text{if Orientation}_j = Left
\end{cases} \text{at Time = } i \\
Orientation_j = \text{Sail Orientation of Individual}_j \text{ at Time = } i
$$



```{r PP Movement, eval=F, include=TRUE}
# Movement of Physalia
physaliaMovement <- function(physalia, glaucus){
  
  # Boundary conditions for movement
  if(physalia$x >= 100 | physalia$y >= 100 | physalia$y <= 0){ 
    physalia$col <- 'green' 
    physalia$status <- 2
    return(physalia)}
  
  # Live condition
    if(physalia$x > 1 & physalia$status != 'EATEN'){
    physalia$col <- 'purple'
    
    # This is a very important part. We have right and left=handed bluebottles
    # They drift in opposite directions - presumably to sustain populations.
    # We need to account for this properly. In addition, we want to add some
    # stochasticity to the movement. This is due to inherent variability
    # in the shape and size of bluebottles, but also due to waves etc.
    
    if(physalia$orientation == 'right') {direction_offset <- rnorm(1,1,0.1)*pi/3} # right-handed drift at 50 degrees from wind direction.
    if(physalia$orientation == 'left') {direction_offset <- rnorm(1,-1,0.1)*pi/3} # left handed drift at

    # Positional update rules: this IS the movement of physalia
    # Wind larger impact on physalia due to sail
    # physalia also have an offset - their sails change the way they interact
    # with wind - this is one of the cool parts in the model.
    # 0.0266 - see Lee, Schaeffer, Groeskamp (2021)
    physalia$x <- max(physalia$x + 0.0266*(wind_strength[round(physalia$x,digits = 2), 
                                                   round(physalia$y, digits = 2)]) * sin(wind_direction[round(physalia$x,digits = 2), 
                                                                                                       round(physalia$y, digits = 2)]+ direction_offset) +
                      current_strength[round(physalia$x,digits = 2), 
                                         round(physalia$y, digits = 2)] * sin(current_direction[round(physalia$x,digits = 2), 
                                                                                                round(physalia$y, digits = 2)]),0)
    
    # Y movement (north - south) uses cosine function
    physalia$y <- max(physalia$y + 0.0266*(wind_strength[round(physalia$x,digits = 2), 
                                                   round(physalia$y, digits = 2)]) * cos(wind_direction[round(physalia$x,digits = 2), 
                                                                                                       round(physalia$y, digits = 2)] + direction_offset) +
                       current_strength[round(physalia$x,digits = 2), 
                                         round(physalia$y, digits = 2)] * cos(current_direction[round(physalia$x,digits = 2), 
                                                                                                round(physalia$y, digits = 2)]),0)
    
    ### Predator module
    
    # We want to simulate damage to the physalia, i.e. being killed by a predator.
    # We use a simple rule: if the glaucus is within feeding range of the physalai
    # for 3 timesteps, the physalia has been eaten completely. The glaucus will then also
    # move on as we delete the physalia. 
    
    # Convert to spatial geometries to allow geometric operations.
    spat.point <- st_point(c(physalia$x, physalia$y))
    
    # We can decide what a reasonable buffer is. This is the same for
    # all physalia. 50 cm seems reasonable
    under.attack.zone <- st_buffer(spat.point, 0.0005)
    
    # Check if there is a predator nearby
    glaucus.df <- rbindlist(glaucus, fill = T)
    glaucus.df.spat <- st_as_sf(glaucus.df , coords = c('x', 'y'))
    
    # Any predators in the detection zone?
    if(any(st_intersects(glaucus.df.spat, under.attack.zone, sparse = F))){
      # If yes, the physalia is 'under attack'
      physalia$underattack <- physalia$underattack + 1
    }
    
    if(physalia$underattack >= 3){
      physalia$status <- 'EATEN'
    }
    
  } else{
    physalia$col <- 'red'
    if(physalia$x < 1){
      physalia$status <- 'BEACHED' # status 1 is beached
    }
  }
  return(physalia)
}

```